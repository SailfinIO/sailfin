// examples/basics/type-conversion.sfn

// Demonstrates type handling and conversion patterns available in Sailfin
// While built-in conversion functions don't exist yet, we can show patterns for type handling

struct NumberWrapper {
    value: number;
    
    fn create(val: number) -> NumberWrapper {
        return new NumberWrapper { value: val };
    }
    
    fn toString(self) -> string {
        // Manual number-to-string conversion by interpolation
        return "{{self.value}}";
    }
    
    fn doubleValue(self) -> number {
        return self.value * 2;
    }
}

struct StringWrapper {
    content: string;
    
    fn create(text: string) -> StringWrapper {
        return new StringWrapper { content: text };
    }
    
    fn getLength(self) -> number {
        // Can't actually get string length yet, but show the pattern
        return 42; // Placeholder - real length calculation not available
    }
    
    fn addSuffix(self, suffix: string) -> string {
        return "{{self.content}}{{suffix}}";
    }
}

fn main() -> void {
    // Working with numbers
    let originalNumber: number = 123;
    let wrapper: NumberWrapper = NumberWrapper.create(originalNumber);
    
    print.info("Original number: {{originalNumber}}");
    print.info("Wrapped number: {{wrapper.value}}");
    print.info("Doubled: {{wrapper.doubleValue()}}");
    
    // Convert number to string using method
    let numberAsString: string = wrapper.toString();
    print.info("Number as string: {{numberAsString}}");
    
    // Working with strings
    let text: string = "Hello";
    let stringWrapper: StringWrapper = StringWrapper.create(text);
    let withSuffix: string = stringWrapper.addSuffix(" World");
    
    print.info("Original text: {{text}}");
    print.info("With suffix: {{withSuffix}}");
    print.info("Mock length: {{stringWrapper.getLength()}}");
    
    // Type patterns - showing how different types can be handled
    let isNumber: bool = true;
    let testValue: number = 456;
    
    if (isNumber) {
        print.info("Handling as number: {{testValue}}");
        let doubled: number = testValue * 2;
        print.info("Doubled value: {{doubled}}");
    } else {
        print.info("Would handle as different type");
    }
    
    print.info("Type handling patterns completed.");
}
