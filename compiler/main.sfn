// main.sfn - Self-hosting Sailfin Compiler

// For now, we'll use a hardcoded test program instead of file I/O
// until we implement proper file operations

// Main entry point - compile a simple test program
fn main() {
    // Test source code - a simple variable declaration and arithmetic
    let source: string = "let x: number = 42; let y: number = x + 8;";
    
    print("Sailfin Self-Hosting Compiler - ARM64 Machine Code Generation");
    print("================================================================");
    print("Source: " + source);
    
    // 1. Lexing: produce a list of tokens
    print("\n1. Lexical Analysis...");
    let tokens: Token[] = lex(source);
    print("Generated " + tokens.length.toString() + " tokens");
    
    // 2. Parsing: create a parser and generate the AST  
    print("\n2. Parsing...");
    let parser: Parser = newParser(tokens);
    let program: Program = parseProgram(parser);
    print("AST generated successfully");
    
    // 3. Code Generation: generate ARM64 assembly code
    print("\n3. Code Generation (ARM64 Assembly)...");
    let asmCode: string = generateCode(program);
    print("Generated assembly code:");
    print("========================");
    print(asmCode);
    print("========================");
    
    print("\nNext steps:");
    print("1. Save this assembly to a .s file");
    print("2. Run: clang -c output.s -o output.o");
    print("3. Run: clang -o output output.o");
    print("4. Run: ./output");
    print("\nSelf-hosting compilation to machine code complete!");
}

// Simple test function to verify the compiler works
fn testCompiler() {
    let testSource: string = "let answer: number = 42;";
    let tokens: Token[] = lex(testSource);
    
    if tokens.length > 0 {
        print("✓ Lexer working");
    } else {
        print("✗ Lexer failed");
    }
}
