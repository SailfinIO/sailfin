// A simple Parser structure
struct Parser {
    tokens: Token[];
    pos: number;
}

// Create a new parser given a token list
fn newParser(tokens: Token[]) -> Parser {
    return new Parser { tokens: tokens, pos: 0 };
}

// Return the current token or an EOF token if finished.
fn current(parser: Parser) -> Token {
    if (parser.pos < parser.tokens.length) {
        return parser.tokens[parser.pos];
    }
    // Create and return a special EOF token if needed.
    return Token("EOF", "", -1);
}

// Advance the parser and return the consumed token.
fn advance(parser: Parser) -> Token {
    let tok = current(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

// Ensure the current token has the expected type; if so, consume it.
fn expect(parser: Parser, expectedType: string) -> Token {
    let tok = current(parser);
    if tok.type == expectedType {
        return advance(parser);
    } else {
        error("Expected " + expectedType + " but found " + tok.type + " at line " + tok.lineno.toString());
    }
}

// --- Parsing Expressions ---
// For our minimal version, we’ll support just numbers and identifiers.
fn parseExpression(parser: Parser) -> Expression {
    return parseBinaryExpression(parser, 0);
}

// Parse binary expressions with operator precedence
fn parseBinaryExpression(parser: Parser, minPrecedence: number) -> Expression {
    let left: Expression = parsePrimaryExpression(parser);
    
    while (true) {
        let tok: Token = current(parser);
        let precedence: number = getOperatorPrecedence(tok.type);
        
        if precedence < minPrecedence {
            break;
        }
        
        advance(parser);  // Consume operator
        let operator: string = tok.value;
        let right: Expression = parseBinaryExpression(parser, precedence + 1);
        
        left = BinaryExpr { left: left, operator: operator, right: right };
    }
    
    return left;
}

// Parse primary expressions (numbers, identifiers, function calls, etc.)
fn parsePrimaryExpression(parser: Parser) -> Expression {
    let tok = current(parser);
    
    if tok.type == "NUMBER" {
        advance(parser);
        return NumberExpr { value: tok.value.toNumber() };
    } else if tok.type == "STRING" {
        advance(parser);
        return StringExpr { value: tok.value };
    } else if tok.type == "IDENTIFIER" {
        advance(parser);
        let name: string = tok.value;
        
        // Check for function call
        if current(parser).type == "LPAREN" {
            advance(parser);  // Consume '('
            let args: Expression[] = [];
            
            // Parse arguments
            if current(parser).type != "RPAREN" {
                args.append(parseExpression(parser));
                while current(parser).type == "COMMA" {
                    advance(parser);  // Consume ','
                    args.append(parseExpression(parser));
                }
            }
            
            expect(parser, "RPAREN");
            return CallExpr { callee: IdentifierExpr { name: name }, arguments: args };
        } else {
            return IdentifierExpr { name: name };
        }
    } else if tok.type == "LPAREN" {
        advance(parser);  // Consume '('
        let expr: Expression = parseExpression(parser);
        expect(parser, "RPAREN");
        return expr;
    } else {
        error("Unexpected token in expression: " + tok.type);
    }
}

// Get operator precedence (higher number = higher precedence)
fn getOperatorPrecedence(tokenType: string) -> number {
    if tokenType == "MULTIPLY" || tokenType == "DIVIDE" {
        return 20;
    } else if tokenType == "PLUS" || tokenType == "MINUS" {
        return 10;
    } else if tokenType == "EQ" || tokenType == "NEQ" || tokenType == "LT" || tokenType == "GT" || tokenType == "LEQ" || tokenType == "GEQ" {
        return 5;
    } else {
        return 0;  // Not a binary operator
    }
}

// --- Parsing Statements ---
// Let’s support variable declarations (e.g. "let x: number = 123;")
// and expression statements.
fn parseStatement(parser: Parser) -> Statement {
    let tok = current(parser);
    if tok.type == "LET" {
         // Parse variable declaration.
         advance(parser); // Consume 'let'
         let identTok = expect(parser, "IDENTIFIER");
         
         // Optionally, check for a type annotation.
         let varType: string = "";
         if (current(parser).type == "COLON") {
             advance(parser);  // Consume ':'
             let typeTok = expect(parser, "IDENTIFIER");
             varType = typeTok.value;
         }
         
         // Expect an assignment operator
         expect(parser, "ASSIGN");
         let expr = parseExpression(parser);
         // End the declaration with a semicolon.
         expect(parser, "SEMICOLON");
         
         return VariableDeclaration { name: identTok.value, var_type: varType, value: expr };
    } else if tok.type == "IF" {
         // Parse if statement
         advance(parser);  // Consume 'if'
         let condition: Expression = parseExpression(parser);
         
         expect(parser, "LBRACE");
         let thenBody: Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             thenBody.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         let elseBody: Statement[] = [];
         if current(parser).type == "ELSE" {
             advance(parser);  // Consume 'else'
             expect(parser, "LBRACE");
             
             while current(parser).type != "RBRACE" {
                 elseBody.append(parseStatement(parser));
             }
             
             expect(parser, "RBRACE");
         }
         
         return IfStatement { 
             condition: condition, 
             thenBody: thenBody, 
             elseBody: elseBody 
         };
    } else if tok.type == "RETURN" {
         // Parse return statement
         advance(parser);  // Consume 'return'
         let expr: Expression = NilExpr {};
         
         if current(parser).type != "SEMICOLON" {
             expr = parseExpression(parser);
         }
         
         expect(parser, "SEMICOLON");
         return ReturnStatement { expression: expr };
    } else {
         // If not a variable declaration, assume an expression statement.
         let expr = parseExpression(parser);
         expect(parser, "SEMICOLON");
         return ExpressionStatement { expression: expr };
    }
}

// --- Parsing the Entire Program ---
fn parseProgram(parser: Parser) -> Program {
    let stmts: Statement[] = [];
    while (current(parser).type != "EOF") {
         let stmt = parseStatement(parser);
         stmts.append(stmt);
    }
    return Program { statements: stmts };
}
