// A simple Parser structure
struct Parser {
    tokens: Token[];
    pos: number;
}

// Create a new parser given a token list
fn newParser(tokens: Token[]) -> Parser {
    return new Parser { tokens: tokens, pos: 0 };
}

// Return the current token or an EOF token if finished.
fn current(parser: Parser) -> Token {
    if (parser.pos < parser.tokens.length) {
        return parser.tokens[parser.pos];
    }
    // Create and return a special EOF token if needed.
    return Token("EOF", "", -1);
}

// Advance the parser and return the consumed token.
fn advance(parser: Parser) -> Token {
    let tok = current(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

// Ensure the current token has the expected type; if so, consume it.
fn expect(parser: Parser, expectedType: string) -> Token {
    let tok = current(parser);
    if tok.type == expectedType {
        return advance(parser);
    } else {
        error("Expected " + expectedType + " but found " + tok.type + " at line " + tok.lineno.toString());
    }
}

// Peek at the next token without consuming it
fn peek(parser: Parser) -> Token {
    if parser.pos + 1 < parser.tokens.length {
        return parser.tokens[parser.pos + 1];
    } else {
        // Return EOF token if at end
        return Token { type: "EOF", value: "", lineno: 0 };
    }
}

// --- Parsing Expressions ---
// For our minimal version, we’ll support just numbers and identifiers.
fn parseExpression(parser: Parser) -> Expression {
    return parseBinaryExpression(parser, 0);
}

// Parse binary expressions with operator precedence
fn parseBinaryExpression(parser: Parser, minPrecedence: number) -> Expression {
    let left: Expression = parsePrimaryExpression(parser);
    
    while (true) {
        let tok: Token = current(parser);
        let precedence: number = getOperatorPrecedence(tok.type);
        
        if precedence < minPrecedence {
            break;
        }
        
        advance(parser);  // Consume operator
        let operator: string = tok.value;
        let right: Expression = parseBinaryExpression(parser, precedence + 1);
        
        left = BinaryExpr { left: left, operator: operator, right: right };
    }
    
    return left;
}

// Parse primary expressions (numbers, identifiers, function calls, etc.)
fn parsePrimaryExpression(parser: Parser) -> Expression {
    let tok = current(parser);
    
    if tok.type == "NUMBER" {
        advance(parser);
        return NumberExpr { value: tok.value.toNumber() };
    } else if tok.type == "STRING" {
        advance(parser);
        return StringExpr { value: tok.value };
    } else if tok.type == "LBRACKET" {
        // Parse array literal [1, 2, 3]
        advance(parser);  // Consume '['
        let elements: Expression[] = [];
        
        // Parse array elements
        if current(parser).type != "RBRACKET" {
            elements.append(parseExpression(parser));
            while current(parser).type == "COMMA" {
                advance(parser);  // Consume ','
                elements.append(parseExpression(parser));
            }
        }
        
        expect(parser, "RBRACKET");
        return ArrayExpr { elements: elements };
    } else if tok.type == "IDENTIFIER" {
        advance(parser);
        let name: string = tok.value;
        let expr: Expression = IdentifierExpr { name: name };
        
        // Handle postfix operations (function calls and array indexing)
        while (true) {
            if current(parser).type == "LPAREN" {
                // Function call
                advance(parser);  // Consume '('
                let args: Expression[] = [];
                
                // Parse arguments
                if current(parser).type != "RPAREN" {
                    args.append(parseExpression(parser));
                    while current(parser).type == "COMMA" {
                        advance(parser);  // Consume ','
                        args.append(parseExpression(parser));
                    }
                }
                
                expect(parser, "RPAREN");
                expr = CallExpr { callee: expr, arguments: args };
            } else if current(parser).type == "LBRACKET" {
                // Array indexing
                advance(parser);  // Consume '['
                let index: Expression = parseExpression(parser);
                expect(parser, "RBRACKET");
                expr = IndexExpr { array: expr, index: index };
            } else {
                break;  // No more postfix operations
            }
        }
        
        return expr;
    } else if tok.type == "LPAREN" {
        advance(parser);  // Consume '('
        let expr: Expression = parseExpression(parser);
        expect(parser, "RPAREN");
        return expr;
    } else {
        error("Unexpected token in expression: " + tok.type);
    }
}

// Get operator precedence (higher number = higher precedence)
fn getOperatorPrecedence(tokenType: string) -> number {
    if tokenType == "MULTIPLY" || tokenType == "DIVIDE" {
        return 20;
    } else if tokenType == "PLUS" || tokenType == "MINUS" {
        return 10;
    } else if tokenType == "EQ" || tokenType == "NEQ" || tokenType == "LT" || tokenType == "GT" || tokenType == "LEQ" || tokenType == "GEQ" {
        return 5;
    } else {
        return 0;  // Not a binary operator
    }
}

// --- Parsing Statements ---
// Let’s support variable declarations (e.g. "let x: number = 123;")
// and expression statements.
fn parseStatement(parser: Parser) -> Statement {
    let tok = current(parser);
    if tok.type == "LET" || tok.type == "MUT" {
         // Parse variable declaration.
         let isMutable: bool = tok.type == "MUT";
         advance(parser); // Consume 'let' or 'mut'
         let identTok = expect(parser, "IDENTIFIER");
         
         // Optionally, check for a type annotation.
         let varType: string = "";
         if (current(parser).type == "COLON") {
             advance(parser);  // Consume ':'
             let typeTok = expect(parser, "IDENTIFIER");
             varType = typeTok.value;
         }
         
         // Expect an assignment operator
         expect(parser, "ASSIGN");
         let expr = parseExpression(parser);
         // End the declaration with a semicolon.
         expect(parser, "SEMICOLON");
         
         return VariableDeclaration { 
             name: identTok.value, 
             var_type: varType, 
             value: expr,
             isMutable: isMutable
         };
    } else if tok.type == "IDENTIFIER" {
         // Check if this is an assignment (x = value) or expression statement
         let nextTok: Token = peek(parser);
         if nextTok.type == "ASSIGN" {
             // Parse assignment statement
             let identTok: Token = advance(parser);  // Consume identifier
             expect(parser, "ASSIGN");
             let expr: Expression = parseExpression(parser);
             expect(parser, "SEMICOLON");
             
             return AssignmentStatement {
                 target: identTok.value,
                 value: expr
             };
         } else {
             // Expression statement
             let expr = parseExpression(parser);
             expect(parser, "SEMICOLON");
             return ExpressionStatement { expression: expr };
         }
    } else if tok.type == "FN" {
         // Parse function declaration
         advance(parser);  // Consume 'fn'
         let nameTok: Token = expect(parser, "IDENTIFIER");
         
         expect(parser, "LPAREN");
         let params: Parameter[] = [];
         
         // Parse parameters
         if current(parser).type != "RPAREN" {
             params.append(parseParameter(parser));
             while current(parser).type == "COMMA" {
                 advance(parser);  // Consume ','
                 params.append(parseParameter(parser));
             }
         }
         
         expect(parser, "RPAREN");
         
         // Parse return type
         let returnType: string = "";
         if current(parser).type == "ARROW" {
             advance(parser);  // Consume '->'
             let typeTok: Token = expect(parser, "IDENTIFIER");
             returnType = typeTok.value;
         }
         
         // Parse function body
         expect(parser, "LBRACE");
         let body: Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             body.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         return FunctionDeclaration { 
             name: nameTok.value, 
             parameters: params, 
             returnType: returnType, 
             body: body 
         };
    } else if tok.type == "IF" {
         // Parse if statement
         advance(parser);  // Consume 'if'
         let condition: Expression = parseExpression(parser);
         
         expect(parser, "LBRACE");
         let thenBody: Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             thenBody.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         let elseBody: Statement[] = [];
         if current(parser).type == "ELSE" {
             advance(parser);  // Consume 'else'
             expect(parser, "LBRACE");
             
             while current(parser).type != "RBRACE" {
                 elseBody.append(parseStatement(parser));
             }
             
             expect(parser, "RBRACE");
         }
         
         return IfStatement { 
             condition: condition, 
             thenBody: thenBody, 
             elseBody: elseBody 
         };
    } else if tok.type == "WHILE" {
         // Parse while loop
         advance(parser);  // Consume 'while'
         let condition: Expression = parseExpression(parser);
         
         expect(parser, "LBRACE");
         let body: Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             body.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         return WhileStatement { 
             condition: condition, 
             body: body 
         };
    } else if tok.type == "RETURN" {
         // Parse return statement
         advance(parser);  // Consume 'return'
         let expr: Expression = NilExpr {};
         
         if current(parser).type != "SEMICOLON" {
             expr = parseExpression(parser);
         }
         
         expect(parser, "SEMICOLON");
         return ReturnStatement { expression: expr };
    } else {
         // Default to expression statement
         let expr = parseExpression(parser);
         expect(parser, "SEMICOLON");
         return ExpressionStatement { expression: expr };
    }
}

// Parse function parameter
fn parseParameter(parser: Parser) -> Parameter {
    let nameTok: Token = expect(parser, "IDENTIFIER");
    expect(parser, "COLON");
    let typeTok: Token = expect(parser, "IDENTIFIER");
    
    return Parameter { name: nameTok.value, paramType: typeTok.value };
}

// --- Parsing the Entire Program ---
fn parseProgram(parser: Parser) -> Program {
    let stmts: Statement[] = [];
    while (current(parser).type != "EOF") {
         let stmt = parseStatement(parser);
         stmts.append(stmt);
    }
    return Program { statements: stmts };
}
