// Import AST nodes from ast.sfn
import "ast.sfn" as AST;

// Token definition (from lexer.sfn)
struct Token {
    type: string;
    value: string;
    lineno: number;
}

// All AST nodes are now imported from ast.sfn

// A simple Parser structure
struct Parser {
    tokens: Token[];
    pos: number;
}

// Create a new parser given a token list
fn newParser(tokens: Token[]) -> Parser {
    return new Parser { tokens: tokens, pos: 0 };
}

// Return the current token or an EOF token if finished.
fn current(parser: Parser) -> Token {
    let pos: number = parser.pos;
    let length: number = parser.tokens.length;
    if pos < length {
        return parser.tokens[pos];
    }
    // Create and return a special EOF token if needed.
    return new Token { type: "EOF", value: "", lineno: -1 };
}

// Advance the parser and return the consumed token.
fn advance(parser: Parser) -> Token {
    let tok = current(parser);
    parser.pos = parser.pos + 1;
    return tok;
}

// Ensure the current token has the expected type; if so, consume it.
fn expect(parser: Parser, expectedType: string) -> Token {
    let tok = current(parser);
    if tok.type == expectedType {
        return advance(parser);
    } else {
        error("Expected " + expectedType + " but found " + tok.type + " at line " + tok.lineno.toString());
    }
}

// Peek at the next token without consuming it
fn peek(parser: Parser) -> Token {
    let nextPos: number = parser.pos + 1;
    let tokensLength: number = parser.tokens.length;
    if nextPos >= tokensLength {
        let eofToken: Token = new Token { type: "EOF", value: "", lineno: 0 };
        return eofToken;
    }
    let nextToken: Token = parser.tokens[nextPos];
    return nextToken;
}

// --- Parsing Expressions ---
// For our minimal version, we’ll support just numbers and identifiers.
fn parseExpression(parser: Parser) -> AST.Expression {
    return parseBinaryExpression(parser, 0);
}

// Parse binary expressions with operator precedence
fn parseBinaryExpression(parser: Parser, minPrecedence: number) -> AST.Expression {
    let left: AST.Expression = parsePrimaryExpression(parser);
    
    while (true) {
        let tok: Token = current(parser);
        let precedence: number = getOperatorPrecedence(tok.type);
        
        if precedence < minPrecedence {
            break;
        }
        
        advance(parser);  // Consume operator
        let operator: string = tok.value;
        let right: AST.Expression = parseBinaryExpression(parser, precedence + 1);
        
        left = new AST.BinaryExpr { left: left, operator: operator, right: right };
    }
    
    return left;
}

// Parse primary expressions (numbers, identifiers, function calls, etc.)
fn parsePrimaryExpression(parser: Parser) -> AST.Expression {
    let tok = current(parser);
    
    if tok.type == "NUMBER" {
        advance(parser);
        return new AST.NumberExpr { value: tok.value.toNumber() };
    } else if tok.type == "STRING" {
        advance(parser);
        return new AST.StringExpr { value: tok.value };
    } else if tok.type == "LBRACKET" {
        // Parse array literal [1, 2, 3]
        advance(parser);  // Consume '['
        let elements: AST.Expression[] = [];
        
        // Parse array elements
        if current(parser).type != "RBRACKET" {
            elements.append(parseExpression(parser));
            while current(parser).type == "COMMA" {
                advance(parser);  // Consume ','
                elements.append(parseExpression(parser));
            }
        }
        
        expect(parser, "RBRACKET");
        return new AST.ArrayExpr { elements: elements };
    } else if tok.type == "IDENTIFIER" {
        advance(parser);
        let name: string = tok.value;
        let expr: AST.Expression = new AST.IdentifierExpr { name: name };
        
        // Handle postfix operations (function calls and array indexing)
        while (true) {
            if current(parser).type == "LPAREN" {
                // Function call
                advance(parser);  // Consume '('
                let args: AST.Expression[] = [];
                
                // Parse arguments
                if current(parser).type != "RPAREN" {
                    args.append(parseExpression(parser));
                    while current(parser).type == "COMMA" {
                        advance(parser);  // Consume ','
                        args.append(parseExpression(parser));
                    }
                }
                
                expect(parser, "RPAREN");
                expr = new AST.CallExpr { callee: expr, arguments: args };
            } else if current(parser).type == "LBRACKET" {
                // Array indexing
                advance(parser);  // Consume '['
                let index: AST.Expression = parseExpression(parser);
                expect(parser, "RBRACKET");
                expr = new AST.IndexExpr { array: expr, index: index };
            } else {
                break;  // No more postfix operations
            }
        }
        
        return expr;
    } else if tok.type == "LPAREN" {
        advance(parser);  // Consume '('
        let expr: AST.Expression = parseExpression(parser);
        expect(parser, "RPAREN");
        return expr;
    } else {
        error("Unexpected token in expression: " + tok.type);
    }
}

// Get operator precedence (higher number = higher precedence)
fn getOperatorPrecedence(tokenType: string) -> number {
    if tokenType == "MULTIPLY" || tokenType == "DIVIDE" {
        return 20;
    } else if tokenType == "PLUS" || tokenType == "MINUS" {
        return 10;
    } else if tokenType == "EQ" || tokenType == "NEQ" || tokenType == "LT" || tokenType == "GT" || tokenType == "LEQ" || tokenType == "GEQ" {
        return 5;
    } else {
        return 0;  // Not a binary operator
    }
}

// --- Parsing Statements ---
// Let’s support variable declarations (e.g. "let x: number = 123;")
// and expression statements.
fn parseStatement(parser: Parser) -> AST.Statement {
    let tok = current(parser);
    if tok.type == "LET" || tok.type == "MUT" {
         // Parse variable declaration.
         let isMutable: bool = tok.type == "MUT";
         advance(parser); // Consume 'let' or 'mut'
         let identTok = expect(parser, "IDENTIFIER");
         
         // Optionally, check for a type annotation.
         let varType: string = "";
         if (current(parser).type == "COLON") {
             advance(parser);  // Consume ':'
             let typeTok = expect(parser, "IDENTIFIER");
             varType = typeTok.value;
         }
         
         // Expect an assignment operator
         expect(parser, "ASSIGN");
         let expr = parseExpression(parser);
         // End the declaration with a semicolon.
         expect(parser, "SEMICOLON");
         
         return new AST.VariableDeclaration { 
             name: identTok.value, 
             var_type: varType, 
             value: expr,
             isMutable: isMutable
         };
    } else if tok.type == "IDENTIFIER" {
         // Check if this is an assignment (x = value) or expression statement
         let nextTok: Token = peek(parser);
         if nextTok.type == "ASSIGN" {
             // Parse assignment statement
             let identTok: Token = advance(parser);  // Consume identifier
             expect(parser, "ASSIGN");
             let expr: AST.Expression = parseExpression(parser);
             expect(parser, "SEMICOLON");
             
             return new AST.AssignmentStatement {
                 target: identTok.value,
                 value: expr
             };
         } else {
             // Expression statement
             let expr = parseExpression(parser);
             expect(parser, "SEMICOLON");
             return new AST.ExpressionStatement { expression: expr };
         }
    } else if tok.type == "STRUCT" {
         // Parse struct declaration
         advance(parser);  // Consume 'struct'
         let nameTok: Token = expect(parser, "IDENTIFIER");
         
         // TODO: Parse optional implements clause
         
         expect(parser, "LBRACE");
         let fields: AST.FieldDeclaration[] = [];
         
         // Parse struct fields
         while current(parser).type != "RBRACE" {
             let fieldName: Token = expect(parser, "IDENTIFIER");
             expect(parser, "COLON");
             let fieldType: Token = expect(parser, "IDENTIFIER");
             expect(parser, "SEMICOLON");
             
             fields.append(new AST.FieldDeclaration {
                 name: fieldName.value,
                 fieldType: fieldType.value
             });
         }
         
         expect(parser, "RBRACE");
         
         return new AST.StructDeclaration {
             name: nameTok.value,
             fields: fields
         };
    } else if tok.type == "FN" {
         // Parse function declaration
         advance(parser);  // Consume 'fn'
         let nameTok: Token = expect(parser, "IDENTIFIER");
         
         expect(parser, "LPAREN");
         let params: AST.Parameter[] = [];
         
         // Parse parameters
         if current(parser).type != "RPAREN" {
             params.append(parseParameter(parser));
             while current(parser).type == "COMMA" {
                 advance(parser);  // Consume ','
                 params.append(parseParameter(parser));
             }
         }
         
         expect(parser, "RPAREN");
         
         // Parse return type
         let returnType: string = "";
         if current(parser).type == "ARROW" {
             advance(parser);  // Consume '->'
             let typeTok: Token = expect(parser, "IDENTIFIER");
             returnType = typeTok.value;
         }
         
         // Parse function body
         expect(parser, "LBRACE");
         let body: AST.Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             body.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         return new AST.FunctionDeclaration { 
             name: nameTok.value, 
             parameters: params, 
             returnType: returnType, 
             body: body 
         };
    } else if tok.type == "IF" {
         // Parse if statement
         advance(parser);  // Consume 'if'
         let condition: AST.Expression = parseExpression(parser);
         
         expect(parser, "LBRACE");
         let thenBody: AST.Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             thenBody.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         let elseBody: AST.Statement[] = [];
         if current(parser).type == "ELSE" {
             advance(parser);  // Consume 'else'
             expect(parser, "LBRACE");
             
             while current(parser).type != "RBRACE" {
                 elseBody.append(parseStatement(parser));
             }
             
             expect(parser, "RBRACE");
         }
         
         return new AST.IfStatement { 
             condition: condition, 
             thenBody: thenBody, 
             elseBody: elseBody 
         };
    } else if tok.type == "WHILE" {
         // Parse while loop
         advance(parser);  // Consume 'while'
         let condition: AST.Expression = parseExpression(parser);
         
         expect(parser, "LBRACE");
         let body: AST.Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             body.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         return new AST.WhileStatement { 
             condition: condition, 
             body: body 
         };
    } else if tok.type == "FOR" {
         // Parse for loop
         advance(parser);  // Consume 'for'
         expect(parser, "LPAREN");
         
         // Parse initialization
         let init: AST.Statement = parseStatement(parser);
         
         // Parse condition
         let condition: AST.Expression = parseExpression(parser);
         expect(parser, "SEMICOLON");
         
         // Parse update
         let update: AST.Statement = parseStatement(parser);
         expect(parser, "RPAREN");
         
         // Parse body
         expect(parser, "LBRACE");
         let body: AST.Statement[] = [];
         
         while current(parser).type != "RBRACE" {
             body.append(parseStatement(parser));
         }
         
         expect(parser, "RBRACE");
         
         return new AST.ForStatement { 
             init: init,
             condition: condition, 
             update: update,
             body: body 
         };
    } else if tok.type == "RETURN" {
         // Parse return statement
         advance(parser);  // Consume 'return'
         let expr: AST.Expression = new AST.NilExpr {};
         
         if current(parser).type != "SEMICOLON" {
             expr = parseExpression(parser);
         }
         
         expect(parser, "SEMICOLON");
         return new AST.ReturnStatement { expression: expr };
    } else if tok.type == "IMPORT" {
         // Parse import statement
         advance(parser);  // Consume 'import'
         let modulePathTok: Token = expect(parser, "STRING");
         let modulePath: string = modulePathTok.value;
         
         let alias: string = "";
         if current(parser).type == "IDENTIFIER" && current(parser).value == "as" {
             advance(parser);  // Consume 'as'
             let aliasTok: Token = expect(parser, "IDENTIFIER");
             alias = aliasTok.value;
         }
         
         expect(parser, "SEMICOLON");
         return new AST.ImportStatement { 
             modulePath: modulePath, 
             alias: alias 
         };
    } else if tok.type == "EXPORT" {
         // Parse export statement  
         advance(parser);  // Consume 'export'
         let declaration: AST.Statement = parseStatement(parser);
         return new AST.ExportStatement { declaration: declaration };
    } else {
         // Default to expression statement
         let expr = parseExpression(parser);
         expect(parser, "SEMICOLON");
         return new AST.ExpressionStatement { expression: expr };
    }
}

// Parse function parameter
fn parseParameter(parser: Parser) -> AST.Parameter {
    let nameTok: Token = expect(parser, "IDENTIFIER");
    expect(parser, "COLON");
    let typeTok: Token = expect(parser, "IDENTIFIER");
    
    return new AST.Parameter { name: nameTok.value, paramType: typeTok.value };
}

// --- Parsing the Entire Program ---
fn parseProgram(parser: Parser) -> AST.Program {
    let stmts: AST.Statement[] = [];
    while (current(parser).type != "EOF") {
         let stmt = parseStatement(parser);
         stmts.append(stmt);
    }
    return new AST.Program { statements: stmts };
}
